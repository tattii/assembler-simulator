var app = angular.module('ASMSimulator', []);
;app.service('assembler', [ function () {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
			var regex = /^[\t ]*([A-Za-z]+)(?:[\t ]+([\w\-]+)[\t ]*?(?:,[\t ]*?([\w\-\(\)]+))*)*/;
            var regexNum = /^[-+]?[0-9]+$/;
			var regexRegister = /^R([0-7])$/;
			var regexMemAddress = /^(.*?)\((.*?)\)$/;

			// Contains the program code & data generated by the assembler
            var code = [];

            // Split text into code lines
            var lines = input.split('\n');

            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
				if (input === undefined) throw "undefined d";
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    throw "Invalid number format";
                }
            };

            // Allowed registers: R[0-7]
            var parseRegister = function (input) {
				if (input === undefined) throw "undefined register";
                input = input.toUpperCase();

				if (input.match(regexRegister)){
					return parseInt(RegExp.$1);
                } else {
                    return undefined;
                }
            };

			var parseMemAddress = function (input) {
				if (input === undefined) throw "undefined Memory address";

				if (input.match(regexMemAddress)){
					return {
						d:  parseInt(RegExp.$1),
						rb: parseRegister(RegExp.$2)
					};
                } else {
                    throw "invalid Memory address";
                }
            };

			// util functions
			var zpad = function (input, n) {
				if(input === undefined){
					input = "";
				}
				if(input.length >= n){
					return input;
				}
				var zeros = "0".repeat(n);
				return (zeros + input).slice(-1 * n);
			};

			var b = function(d) {
				return parseInt(d, 2);
			};
			var B3 = function(d) {
				return zpad(d.toString(2), 3);
			};
			var B8 = function(d) {
				var bin;
				if (d >= 0){
					return zpad(d.toString(2), 8);
				}else{
					return "1" + zpad((d+128).toString(2), 7);
				}
			};

			var hex = function(d) {
				return parseInt(d, 16);
			};

			var alu_op = {
				ADD: '0000',
				SUB: '0001',
				AND: '0010',
				OR:  '0011',
				XOR: '0100',
				CMP: '0101',
				MOV: '0110'
			};
			
			var shift_op = {
				SLL: '1000',
				SLR: '1001',
				SRL: '1010',
				SRA: '1011'
			};

			var branch_cond = {
				BE:  '000',
				BLT: '001',
				BLE: '010',
				BNE: '011'
			};


			// parse
            for (var i = 0, l = lines.length; i < l; i++) {
                try {
                    var match = regex.exec(lines[i]);
					if (match[1] !== undefined) {
						var instr = match[1].toUpperCase();
						var p1, p2, opCode;

						switch (instr) {
							// ALU
							case 'ADD':
							case 'SUB':
							case 'AND':
							case 'OR':
							case 'XOR':
							case 'CMP':
							case 'MOV':
								p1 = parseRegister(match[2]);
								p2 = parseRegister(match[3]);

								opCode = b('11' + B3(p2) + B3(p1) + alu_op[instr] + '0000');
								code.push({op:instr, code: opCode, rd: p1, rs: p2});
								break;

							// Shift
							case 'SLL':
							case 'SLR':
							case 'SRL':
							case 'SRA':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('11' + '000' + B3(p1) + shift_op[instr] + B4(p2));
								code.push({op:instr, code: opCode, rd: p1, d: p2});
								break;

							// IN *
							case 'OUT':
								p1 = parseRegister(match[2]);
								opCode = b('11' + B3(p1) + '000' + '1101' + '0000');
								code.push({op:'OUT', code: opCode, rs: p1});
								break;

							case 'HLT':
								opCode = hex('c0f0');
								code.push({op: 'HLT', code: opCode});
								break;

							// memory
							case 'LD':
							case 'ST':
								p1 = parseRegister(match[2]);
								p2 = parseMemAddress(match[3]);

								var op = (instr=='LD') ? '00' : '01';
								opCode = b(op + B3(p1) + B3(p2.rb) + B8(p2.d));
								code.push({op:instr, code: opCode, ra: p1, rb: p2.rb, d: p2.d});
								break;


							// 
							case 'LI':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'000'+B3(p1)+B8(p2));
								code.push({op:'LI', code: opCode, rb: p1, d: p2});
								break;

							case 'ADDI':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'001'+B3(p1)+B8(p2));
								code.push({op:'ADDI', code: opCode, rb: p1, d: p2});
								break;

							case 'B':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'100'+B3(p1)+B8(p2));
								code.push({op:'LI', code: opCode, rb: p1, d: p2});
								break;


							// branch
							case 'BE':
							case 'BLT':
							case 'BLE':
							case 'BNE':
								p1 = parseNumber(match[2]);

								opCode = b('10'+'111' + branch_cond[instr] + B8(p1));
								code.push({op:instr, code: opCode, d: p1});
								break;

							default:
								throw "Invalid instruction: " + match[1];
						}
                    } else {
                        // Check if line starts with a comment otherwise the line contains an error and can not be parsed
                        var line = lines[i].trim();
                        if (line !== "" && line.slice(0, 1) !== ";") {
                            throw "Syntax error";
                        }
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }


            return code;
        }
    };
}]);
;app.service('cpu', ['memory', function(memory) {
    var cpu = {
        step: function() {
            var self = this;

            if (self.fault === true) {
                throw "FAULT. Reset to continue.";
            }

            try {

                var jump = function(newPC) {
                    if (newPC < 0 || newPC >= memory.data.length) {
                        throw "PC outside memory";
                    } else {
                        self.pc = newPC;
                    }
                };

                var division = function(divisor) {
                    if (divisor === 0) {
                        throw "Division by 0";
                    }

                    return Math.floor(self.gpr[0] / divisor);
                };

                if (self.pc < 0 || self.pc >= memory.data.length) {
                    throw "Program Counter is outside of memory";
                }
                
                var instr = memory.loadInstr(self.pc);
				console.log(instr);
                switch(instr.op) {
					case 'HLT':
						return false;
					case 'LI':
						self.gpr[instr.rb] = instr.d;
						self.pc++;
						break;

					case 'MOV':
						self.gpr[instr.rd] = self.gpr[instr.rs];
						self.pc++;
						break;
					
					default:
                        throw "Invalid op code: " + instr;
                }

                return true;
            } catch(e) {
                self.fault = true;
                throw e;
            }
        },
        reset: function() {
            var self = this;

            self.gpr = [0, 0, 0, 0, 0, 0, 0, 0];
			self.pc = 0;
            self.zero = false;
            self.carry = false;
            self.fault = false;
            self.v = false;
			self.output = 0;
        }
    };

    cpu.reset();
    return cpu;
}]);
;app.service('memory', [function () {
    var memory = {
        data: Array(256),
        lastAccess: -1,
        load: function (address) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;
            return self.data[address];
        },
        loadInstr: function (address) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;
            return self.instrs[address];
        },
        store: function (address, value) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;
            self.data[address] = value;
        },
        reset: function () {
            var self = this;

            self.lastAccess = -1;
            for (var i = 0, l = self.data.length; i < l; i++) {
                self.data[i] = 0;
                if(self.instrs) self.instrs = null;
            }
        }
    };

    memory.reset();
    return memory;
}]);
;app.service('opcodes', [function() {
    var opcodes = {
        NONE: 0,
        MOV_REG_TO_REG: 1,
        MOV_ADDRESS_TO_REG: 2,
        MOV_REGADDRESS_TO_REG: 3,
        MOV_REG_TO_ADDRESS: 4,
        MOV_REG_TO_REGADDRESS: 5,
        MOV_NUMBER_TO_REG: 6,
        MOV_NUMBER_TO_ADDRESS: 7,
        MOV_NUMBER_TO_REGADDRESS: 8,
        ADD_REG_TO_REG: 10,
        ADD_REGADDRESS_TO_REG: 11,
        ADD_ADDRESS_TO_REG: 12,
        ADD_NUMBER_TO_REG: 13,
        SUB_REG_FROM_REG: 14,
        SUB_REGADDRESS_FROM_REG: 15,
        SUB_ADDRESS_FROM_REG: 16,
        SUB_NUMBER_FROM_REG: 17,
        INC_REG: 18,
        DEC_REG: 19,
        CMP_REG_WITH_REG: 20,
        CMP_REGADDRESS_WITH_REG: 21,
        CMP_ADDRESS_WITH_REG: 22,
        CMP_NUMBER_WITH_REG: 23,
        JMP_REGADDRESS: 30,
        JMP_ADDRESS: 31,
        JC_REGADDRESS: 32,
        JC_ADDRESS: 33,
        JNC_REGADDRESS: 34,
        JNC_ADDRESS: 35,
        JZ_REGADDRESS: 36,
        JZ_ADDRESS: 37,
        JNZ_REGADDRESS: 38,
        JNZ_ADDRESS: 39,
        JA_REGADDRESS: 40,
        JA_ADDRESS: 41,
        JNA_REGADDRESS: 42,
        JNA_ADDRESS: 43,
        PUSH_REG: 50,
        PUSH_REGADDRESS: 51,
        PUSH_ADDRESS: 52,
        PUSH_NUMBER: 53,
        POP_REG: 54,
        CALL_REGADDRESS: 55,
        CALL_ADDRESS: 56,
        RET: 57,
        MUL_REG: 60,
        MUL_REGADDRESS: 61,
        MUL_ADDRESS: 62,
        MUL_NUMBER: 63,
        DIV_REG: 64,
        DIV_REGADDRESS: 65,
        DIV_ADDRESS: 66,
        DIV_NUMBER: 67,
        AND_REG_WITH_REG: 70,
        AND_REGADDRESS_WITH_REG: 71,
        AND_ADDRESS_WITH_REG: 72,
        AND_NUMBER_WITH_REG: 73,
        OR_REG_WITH_REG: 74,
        OR_REGADDRESS_WITH_REG: 75,
        OR_ADDRESS_WITH_REG: 76,
        OR_NUMBER_WITH_REG: 77,
        XOR_REG_WITH_REG: 78,
        XOR_REGADDRESS_WITH_REG: 79,
        XOR_ADDRESS_WITH_REG: 80,
        XOR_NUMBER_WITH_REG: 81,
        NOT_REG: 82,
        SHL_REG_WITH_REG: 90,
        SHL_REGADDRESS_WITH_REG: 91,
        SHL_ADDRESS_WITH_REG: 92,
        SHL_NUMBER_WITH_REG: 93,
        SHR_REG_WITH_REG: 94,
        SHR_REGADDRESS_WITH_REG: 95,
        SHR_ADDRESS_WITH_REG: 96,
        SHR_NUMBER_WITH_REG: 97
    };

    return opcodes;
}]);
;app.controller('Ctrl', ['$document', '$scope', '$timeout', 'cpu', 'memory', 'assembler', function ($document, $scope, $timeout, cpu, memory, assembler) {
    $scope.memory = memory;
    $scope.cpu = cpu;
    $scope.error = '';
    $scope.isRunning = false;
    $scope.displayHex = true;
    $scope.displayInstr = true;
    $scope.displayA = false;
    $scope.displayB = false;
    $scope.displayC = false;
    $scope.displayD = false;
    $scope.speeds = [{speed: 1, desc: "1 HZ"},
                     {speed: 4, desc: "4 HZ"},
                     {speed: 8, desc: "8 HZ"},
                     {speed: 16, desc: "16 HZ"}];
    $scope.speed = 4;

	$scope.code = "LI R4,1\nMOV R1,R4\nHLT";
    //$scope.code = "; Simple example\n; Writes Hello World to the output\n\n	JMP start\nhello: DB \"Hello World!\" ; Variable\n       DB 0	; String terminator\n\nstart:\n	MOV C, hello    ; Point to var \n	MOV D, 232	; Point to output\n	CALL print\n        HLT             ; Stop execution\n\nprint:			; print(C:*from, D:*to)\n	PUSH A\n	PUSH B\n	MOV B, 0\n.loop:\n	MOV A, [C]	; Get char from var\n	MOV [D], A	; Write to output\n	INC C\n	INC D  \n	CMP B, [C]	; Check if end\n	JNZ .loop	; jump if not\n\n	POP B\n	POP A\n	RET";

    $scope.reset = function () {
        cpu.reset();
        memory.reset();
        $scope.error = '';
        $scope.selectedLine = -1;
    };

    $scope.executeStep = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }

        try {
            // Execute
            var res = cpu.step();
            return res;
        } catch (e) {
            $scope.error = e;
            return false;
        }
    };

    var runner;
    $scope.run = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }

        $scope.isRunning = true;
        runner = $timeout(function () {
            if ($scope.executeStep() === true) {
                $scope.run();
            } else {
                $scope.isRunning = false;
            }
        }, 1000 / $scope.speed);
    };

    $scope.stop = function () {
        $timeout.cancel(runner);
        $scope.isRunning = false;
    };

    $scope.checkPrgrmLoaded = function () {
        for (var i = 0, l = memory.data.length; i < l; i++) {
            if (memory.data[i] !== 0) {
                return true;
            }
        }

        return false;
    };

    $scope.getChar = function (value) {
        var text = String.fromCharCode(value);

        if (text.trim() === '') {
            return '\u00A0\u00A0';
        } else {
            return text;
        }
    };

    $scope.assemble = function () {
        try {
            $scope.reset();

            var assembly = assembler.go($scope.code);
			memory.instrs = assembly;

            if (assembly.length > memory.data.length)
                throw "Binary code does not fit into the memory. Max " + memory.data.length + " bytes are allowed";

            for (var i = 0, l = assembly.length; i < l; i++) {
                memory.data[i] = assembly[i].code;
            }
        } catch (e) {
            if (e.line !== undefined) {
                $scope.error = e.line + " | " + e.error;
                $scope.selectedLine = e.line;
            } else {
                $scope.error = e.error;
            }
        }
    };

    $scope.jumpToLine = function (index) {
        $document[0].getElementById('sourceCode').scrollIntoView();
        $scope.selectedLine = $scope.mapping[index];
    };


    $scope.isInstruction = function (index) {
        return $scope.mapping !== undefined &&
            $scope.mapping[index] !== undefined &&
            $scope.displayInstr;
    };

    $scope.getMemoryCellCss = function (index) {
        if ($scope.isInstruction(index)) {
            return 'instr-bg';
        } else {
            return '';
        }
    };

    $scope.getMemoryInnerCellCss = function (index) {
        if (index === cpu.ip) {
            return 'marker marker-ip';
        } else if (index === cpu.sp) {
            return 'marker marker-sp';
        } else if (index === cpu.gpr[0] && $scope.displayA) {
            return 'marker marker-a';
        } else if (index === cpu.gpr[1] && $scope.displayB) {
            return 'marker marker-b';
        } else if (index === cpu.gpr[2] && $scope.displayC) {
            return 'marker marker-c';
        } else if (index === cpu.gpr[3] && $scope.displayD) {
            return 'marker marker-d';
        } else {
            return '';
        }
    };
}]);
;app.filter('flag', function() {
    return function(input) {
        return input.toString().toUpperCase();
    };
});
;app.filter('number', function() {
    return function(input, isHex) {
		function zpad(input, n) {
			if(input === undefined){
				input = "";
			}
			if(input.length >= n){
				return input;
			}
			var zeros = "0".repeat(n);
			return (zeros + input).slice(-1 * n);
		}

        if (isHex) {
            var hex = input.toString(16).toUpperCase();
            return zpad(hex, 4);
        } else {
            return input.toString(10);
        }
    };
});
;// Source: http://lostsource.com/2012/11/30/selecting-textarea-line.html
app.directive('selectLine', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            scope.$watch('selectedLine', function () {
                if (scope.selectedLine >= 0) {
                    var lines = element[0].value.split("\n");

                    // Calculate start/end
                    var startPos = 0;
                    for (var x = 0; x < lines.length; x++) {
                        if (x == scope.selectedLine) {
                            break;
                        }
                        startPos += (lines[x].length + 1);
                    }

                    var endPos = lines[scope.selectedLine].length + startPos;

                    // Chrome / Firefox
                    if (typeof(element[0].selectionStart) != "undefined") {
                        element[0].focus();
                        element[0].selectionStart = startPos;
                        element[0].selectionEnd = endPos;
                    }

                    // IE
                    if (document.selection && document.selection.createRange) {
                        element[0].focus();
                        element[0].select();
                        var range = document.selection.createRange();
                        range.collapse(true);
                        range.moveEnd("character", endPos);
                        range.moveStart("character", startPos);
                        range.select();
                    }
                }
            });
        }
    };
}]);
;app.filter('startFrom', function() {
    return function(input, start) {
        start = +start; //parse to int
        return input.slice(start);
    };
});
;app.directive('tabSupport', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            element.bind("keydown", function (e) {
                if (e.keyCode === 9) {
                    var val = this.value;
                    var start = this.selectionStart;
                    var end = this.selectionEnd;

                    this.value = val.substring(0, start) + '\t' + val.substring(end);
                    this.selectionStart = this.selectionEnd = start + 1;

                    e.preventDefault();
                    return false;
                }
            });
        }
    };
}]);
