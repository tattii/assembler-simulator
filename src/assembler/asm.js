app.service('assembler', [ function () {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
			var regex = /^[\t ]*([A-Za-z]+)(?:[\t ]+([\w\-]+)[\t ]*?(?:,[\t ]*?([\w\-\(\)]+))*)*/;
            var regexNum = /^[-+]?[0-9]+$/;
			var regexRegister = /^R([0-7])$/;
			var regexMemAddress = /^(.*?)\((.*?)\)$/;

			// Contains the program code & data generated by the assembler
            var code = [];

            // Split text into code lines
            var lines = input.split('\n');

            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
				if (input === undefined) throw "undefined d";
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    throw "Invalid number format";
                }
            };

            // Allowed registers: R[0-7]
            var parseRegister = function (input) {
				if (input === undefined) throw "undefined register";
                input = input.toUpperCase();

				if (input.match(regexRegister)){
					return parseInt(RegExp.$1);
                } else {
                    return undefined;
                }
            };

			var parseMemAddress = function (input) {
				if (input === undefined) throw "undefined Memory address";

				if (input.match(regexMemAddress)){
					return {
						d:  parseInt(RegExp.$1),
						rb: parseRegister(RegExp.$2)
					};
                } else {
                    throw "invalid Memory address";
                }
            };

			// util functions
			var zpad = function (input, n) {
				if(input === undefined){
					input = "";
				}
				if(input.length >= n){
					return input;
				}
				var zeros = "0".repeat(n);
				return (zeros + input).slice(-1 * n);
			};

			var b = function(d) {
				return parseInt(d, 2);
			};
			var B3 = function(d) {
				return zpad(d.toString(2), 3);
			};
			var B8 = function(d) {
				var bin;
				if (d >= 0){
					return zpad(d.toString(2), 8);
				}else{
					return "1" + zpad((d+128).toString(2), 7);
				}
			};

			var hex = function(d) {
				return parseInt(d, 16);
			};

			var alu_op = {
				ADD: '0000',
				SUB: '0001',
				AND: '0010',
				OR:  '0011',
				XOR: '0100',
				CMP: '0101',
				MOV: '0110'
			};
			
			var shift_op = {
				SLL: '1000',
				SLR: '1001',
				SRL: '1010',
				SRA: '1011'
			};

			var branch_cond = {
				BE:  '000',
				BLT: '001',
				BLE: '010',
				BNE: '011'
			};


			// parse
            for (var i = 0, l = lines.length; i < l; i++) {
                try {
                    var match = regex.exec(lines[i]);
					if (match[1] !== undefined) {
						var instr = match[1].toUpperCase();
						var p1, p2, opCode;

						switch (instr) {
							// ALU
							case 'ADD':
							case 'SUB':
							case 'AND':
							case 'OR':
							case 'XOR':
							case 'CMP':
							case 'MOV':
								p1 = parseRegister(match[2]);
								p2 = parseRegister(match[3]);

								opCode = b('11' + B3(p2) + B3(p1) + alu_op[instr] + '0000');
								code.push({op:instr, code: opCode, rd: p1, rs: p2});
								break;

							// Shift
							case 'SLL':
							case 'SLR':
							case 'SRL':
							case 'SRA':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('11' + '000' + B3(p1) + shift_op[instr] + B4(p2));
								code.push({op:instr, code: opCode, rd: p1, d: p2});
								break;

							// IN *
							case 'OUT':
								p1 = parseRegister(match[2]);
								opCode = b('11' + B3(p1) + '000' + '1101' + '0000');
								code.push({op:'OUT', code: opCode, rs: p1});
								break;

							case 'HLT':
								opCode = hex('c0f0');
								code.push({op: 'HLT', code: opCode});
								break;

							// memory
							case 'LD':
							case 'ST':
								p1 = parseRegister(match[2]);
								p2 = parseMemAddress(match[3]);

								var op = (instr=='LD') ? '00' : '01';
								opCode = b(op + B3(p1) + B3(p2.rb) + B8(p2.d));
								code.push({op:instr, code: opCode, ra: p1, rb: p2.rb, d: p2.d});
								break;


							// 
							case 'LI':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'000'+B3(p1)+B8(p2));
								code.push({op:'LI', code: opCode, rb: p1, d: p2});
								break;

							case 'ADDI':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'001'+B3(p1)+B8(p2));
								code.push({op:'ADDI', code: opCode, rb: p1, d: p2});
								break;

							case 'B':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'100'+B3(p1)+B8(p2));
								code.push({op:'LI', code: opCode, rb: p1, d: p2});
								break;


							// branch
							case 'BE':
							case 'BLT':
							case 'BLE':
							case 'BNE':
								p1 = parseNumber(match[2]);

								opCode = b('10'+'111' + branch_cond[instr] + B8(p1));
								code.push({op:instr, code: opCode, d: p1});
								break;

							default:
								throw "Invalid instruction: " + match[1];
						}
                    } else {
                        // Check if line starts with a comment otherwise the line contains an error and can not be parsed
                        var line = lines[i].trim();
                        if (line !== "" && line.slice(0, 1) !== ";") {
                            throw "Syntax error";
                        }
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }


            return code;
        }
    };
}]);
