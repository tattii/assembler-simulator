app.service('assembler', [ function () {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
			var regex = /^[\t ]*([A-Za-z]+)(?:[\t ]+([\w\-]+)[\t ]*?(?:,[\t ]*?([\w\-\(\)]+))*)*/;
            var regexNum = /^[-+]?[0-9]+$/;
			var regexRegister = /^R([0-7])$/;

			// Contains the program code & data generated by the assembler
            var code = [];

            // Split text into code lines
            var lines = input.split('\n');

            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
				if (input === undefined) throw "d undefined";
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    throw "Invalid number format";
                }
            };

            // Allowed registers: R[0-7]
            var parseRegister = function (input) {
				if (input === undefined) throw "undefined register";
                input = input.toUpperCase();

				if (input.match(regexRegister)){
					return parseInt(RegExp.$1);
                } else {
                    return undefined;
                }
            };


			// util functions
			var zpad = function (input, n, pad) {
				if (pad === undefined) pad = "0";
				if(input === undefined){
					input = "";
				}
				if(input.length >= n){
					return input;
				}
				var zeros = pad.repeat(n);
				return (zeros + input).slice(-1 * n);
			};

			var b = function(d) {
				return parseInt(d, 2);
			};
			var B3 = function(d) {
				return zpad(d.toString(2), 3);
			};
			var B8 = function(d) {
				var bin;
				if (d >= 0){
					return zpad(d.toString(2), 8);
				}else{
					d = ~ d + 1;
					return zpad(d.toString(2), 8, "1");
				}
			};

			var hex = function(d) {
				return parseInt(d, 16);
			};

            var checkNoExtraArg = function (instr, arg) {
                if (arg !== undefined) {
                    throw instr + ": too many arguments";
                }
            };

			// parse
            for (var i = 0, l = lines.length; i < l; i++) {
                try {
                    var match = regex.exec(lines[i]);
					if (match[1] !== undefined) {
						var instr = match[1].toUpperCase();
						var p1, p2, opCode;

						switch (instr) {
							case 'HLT':
								checkNoExtraArg('HLT', match[2]);
								opCode = hex('c0f0');
								code.push({op: 'HLT', code: opCode});
								break;

							case 'MOV':
								p1 = parseRegister(match[2]);
								p2 = parseRegister(match[3]);

								opCode = b('11'+B3(p2)+B3(p1)+'0110'+'0000');
								code.push({op:'MOV', code: opCode, rd: p1, rs: p2});
								break;

							case 'LI':
								p1 = parseRegister(match[2]);
								p2 = parseNumber(match[3]);

								opCode = b('10'+'000'+B3(p1)+B8(p2));
								code.push({op:'LI', code: opCode, rb: p1, d: p2});
								break;

							default:
								throw "Invalid instruction: " + match[1];
						}
                    } else {
                        // Check if line starts with a comment otherwise the line contains an error and can not be parsed
                        var line = lines[i].trim();
                        if (line !== "" && line.slice(0, 1) !== ";") {
                            throw "Syntax error";
                        }
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }


            return code;
        }
    };
}]);
